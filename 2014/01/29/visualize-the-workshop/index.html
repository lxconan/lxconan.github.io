<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  <meta name="baidu-site-verification" content="1pssZD9D7q">
  
  <title>Visualize The Workshop | The Coding Life | A world for dotnet and beyond</title>

  
  <meta name="author" content="Liu Xia">
  

  
  <meta name="description" content="今天这篇文章是准备瞎扯的。平常工作的时候，我希望尽可能的将一切自动化，让自己尽可能的舒适与懒惰。两个输入设备（键盘+鼠标）太累，我只想用一个，例如我不希望翻箱倒柜的去翻找 GO-Agent 在哪里，我希望用一个命令就可以开启它。我希望用一个脚本就完成整个工程的依赖的下载，构建，打包，部署，然后让 Pipeline 去跑自动化的单元测试和集成测试。总之，好像有命令行就足够了，我不需要GUI。
但是，这是不可能的。即使在工作中 80% 的时间都在敲打键盘，但是其余的事件我都在浏览器上转悠，这需要鼠标（我知道 Chrome 上有类似 Vim 快捷键的东西，但是它是有副作用的，基于这种考虑，我很少在测试环境下使用它）。在其他的一些场景下，我也希望有接口有图形化的表示，例如，查看 git 的分支。还有一个领域，那就是 Coach。">
  

  
  
  <meta name="keywords" content="visualize,coaching">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="Visualize The Workshop">

  <meta property="og:site_name" content="The Coding Life">

  
  <meta property="og:image" content="/favicon.ico">
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="The Coding Life" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">The Coding Life</a>
    </h1>
    <p class="site-description">A world for dotnet and beyond</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>Visualize The Workshop</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2014/01/29/visualize-the-workshop/" rel="bookmark">
        <time class="entry-date published" datetime="2014-01-28T18:32:01.000Z">
          2014-01-29
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>今天这篇文章是准备瞎扯的。平常工作的时候，我希望尽可能的将一切自动化，让自己尽可能的舒适与懒惰。两个输入设备（键盘+鼠标）太累，我只想用一个，例如我不希望翻箱倒柜的去翻找 GO-Agent 在哪里，我希望用一个命令就可以开启它。我希望用一个脚本就完成整个工程的依赖的下载，构建，打包，部署，然后让 Pipeline 去跑自动化的单元测试和集成测试。总之，好像有命令行就足够了，我不需要GUI。</p>
<p>但是，这是不可能的。即使在工作中 80% 的时间都在敲打键盘，但是其余的事件我都在浏览器上转悠，这需要鼠标（我知道 Chrome 上有类似 Vim 快捷键的东西，但是它是有副作用的，基于这种考虑，我很少在测试环境下使用它）。在其他的一些场景下，我也希望有接口有图形化的表示，例如，查看 git 的分支。还有一个领域，那就是 Coach。</p>
<a id="more"></a>
<h2 id="只有命令行的-Workshop-简直弱爆了"><a href="#只有命令行的-Workshop-简直弱爆了" class="headerlink" title="只有命令行的 Workshop 简直弱爆了"></a>只有命令行的 Workshop 简直弱爆了</h2><p>相比于 Session 来说，大家更喜欢动手。这可能是由于 Session 以 PPT 为主，例子较少。在不能够主动参与的情况下大家都昏昏欲睡。于是有了各种形式的 Workshop。但是我的确参加过类似于以下这种形式的 Workshop，完全没有可视化的内容，只有命令行的操作，我很不喜欢，我只能说，它弱爆了。</p>
<p>例如，我们现在有一个配置 kvm 的 Workshop。主持人开场之后告诉你，很多版本的 Linux 已经自带了 kvm。我给你的也是这个样子的，不但如此，我已经帮你进行了一些基础的配置。这样我们就可以略掉很多繁琐的操作。首先我们创建一个虚拟硬盘：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-img create -f qcow2 winxp.img 10G</span><br></pre></td></tr></table></figure>
<p>然后创建虚拟机：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo qemu-system-x86_64 -m 512 -drive file=/home/lm/kvm/winxp.img,cache=writeback -localtime -net nic,vlan=0,macaddr=52-54-00-12-34-01 -net tap,vlan=0,ifname=tap0,script=no -boot d -cdrom /home/lm/iso/winxp.iso -smp 2 -soundhw es1370</span><br></pre></td></tr></table></figure>
<p>其中，<code>-m 512</code> 是分配 512MB 内存，<code>-drive file=/home/lm/kvm/winxp.img,cache=writeback</code> 是……</p>
<p>然后……好了我已经不想再说下去了。首先我很奇怪这种 Workshop 针对的对象是什么人呢？高手？那么他完全不需要来听这些东西。初学者？拜托，你希望他照猫画虎以达到培养量产型人才的目的吗？这种可怕的 Workshop 的结果可能是：你准备好了一切，然后大家觉得一共就几个命令，没有学到什么东西；或者在 Workshop 进行的过程中问题层出不穷，但是当出现问题的时候你的听众根本不知道如何解决问题，只能干等着你来救命，或者干脆放弃这次的 Workshop。</p>
<p>你说，想成为高手必须自己如何如何……老实说，我认为你在赤裸裸的逃避身为一个 Coach 的责任。为什么大家只要一步跟不上就步步跟不上，或者即使是跟不上下来之后只能自己去重新整理。因为你没有告诉他思路。你说不是啊，我告诉了啊，我每次都提前说，第一，……；第二，……；我只能说那是没有用的。你最好用一个图来可视化你的思路，或者此次 Workshop 的流程。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌────────────────┐   ┌────────────────┐   ┌────────────────┐ </span><br><span class="line">│  Hard disk     │ + │    Hardware    │ + │      Host      │ = Virtual Machine</span><br><span class="line">└────────────────┘   └────────────────┘   └────────────────┘</span><br><span class="line">        ↑ Install         ↑ Config              ↑ Download</span><br><span class="line">        | system          | CPU, Mem            | and </span><br><span class="line">        | on              | Network..           | Install</span><br><span class="line">┌────────────────┐   ┌────────────────┐   ┌────────────────┐ </span><br><span class="line">│ Install Media  │   │ configuration  │   │      kvm       │</span><br><span class="line">└────────────────┘   └────────────────┘   └────────────────┘</span><br></pre></td></tr></table></figure>
<p>这个图并不一定绝对严谨，但是他有三个好处：第一，极大的减轻听众的心理压力，因为他们看到了这张图会感觉到这个事情可能并不是那么难做；第二，防止听众 Lost，即便是他没有跟上如何配置 Hardware 这一节，但是看了图就知道这并不影响学习其余两个部分；因此他就不会在下载并安装 kvm 这一节还在不断的琢磨，我刚才怎么就配不成 Hardware 呢？继而加剧 Lost。第三，在某些部分 Lost 的情况下有据可查，方便线下自行练习。</p>
<p>另外，使用这种流程图形还有一个好处，那就是听众会记住这些流程，进而会把自己的脚本按流程进行隔离，这总比把一坨东西都揉在一起好多了。</p>
<h2 id="图形是理解抽象的必杀技"><a href="#图形是理解抽象的必杀技" class="headerlink" title="图形是理解抽象的必杀技"></a>图形是理解抽象的必杀技</h2><p>有些时候我们不得不面对一些不容易描述的技术且难以调试的技术，例如 C# 的 Task Parallel System 。当你面对着如下的代码的时候：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Fact</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">complex_await</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> numbers = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">string</span> result = <span class="keyword">await</span> Task.Factory.StartNew(</span><br><span class="line">        () =&gt; V.Start(<span class="string">"task 1"</span>).Sleep(<span class="number">1</span>).Finish(<span class="string">"The numbers are: "</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> number = <span class="keyword">await</span> Task.Factory.StartNew(</span><br><span class="line">            state =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> stateIndex = (<span class="keyword">int</span>) state;</span><br><span class="line">                <span class="keyword">return</span> V.Start(<span class="string">"task "</span> + (stateIndex + <span class="number">2</span>)).Sleep(<span class="number">2</span>).Finish(stateIndex*<span class="number">4</span>);</span><br><span class="line">            &#125;,</span><br><span class="line">            i);</span><br><span class="line">        numbers[i] = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有两个急切需要解决的问题：</p>
<ol>
<li>如何描述，大家才能够了解这段代码到底是如何执行的；</li>
<li>如果听众想自己做实验，写一段类似的代码，那么他有办法知道这段代码是如何执行的吗；</li>
</ol>
<p>这两个问题解决好了，那么你的 Workshop 不仅仅有<strong>鱼</strong>，而且有<strong>渔</strong>。所有的参与者会非常好奇，他们不会满足于只看懂你提供的例子，他们希望自己写一些代码，然后解释他们的代码是怎么执行的。为了达到这个目的，我写了一个小小的工具，使得当你执行上述单元测试的时候，提供如下的输出：</p>
<p><img src="/images/blog/visualize_workshop_1.png" alt="task visualization 1"></p>
<p>一切都是一目了然的，循环外的 <code>Task</code> —— <em>Task 1</em> 首先在 Id 为 7 的线程上执行，在执行完毕之后，循环中的两个 <code>Task</code> 先后在 Id 为 8 和 Id 为 7 的线程上执行。三个 <code>Task</code> 有明确的执行先后关系，估计不用我说你也大概明白 <code>await</code> 的作用是什么了。如果你好奇心足够强，就会自己写一些更酷的代码做测试，例如：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Fact</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">complex_await</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ids = <span class="keyword">new</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">await</span> Task.Factory.StartNew(() =&gt; V.Start(<span class="string">"task 0"</span>).Sleep(<span class="number">1</span>).Finish());</span><br><span class="line">    <span class="keyword">await</span> Task.WhenAll(ids.Select(</span><br><span class="line">        id =&gt; Task.Factory.StartNew(() =&gt; V.Start(<span class="string">"task "</span> + id).Sleep(<span class="number">2</span>).Finish())));</span><br><span class="line">    <span class="keyword">await</span> Task.Factory.StartNew(() =&gt; V.Start(<span class="string">"task 5"</span>).Sleep(<span class="number">1</span>).Finish());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么你将得到如下的可视化执行效果：</p>
<p><img src="/images/blog/visualize_workshop_2.png" alt="task visualization 2"></p>
<p>你甚至可以用它探索 Task Parallel Library 中封装的算法：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Fact</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dig_into_the_algorithm</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Parallel.For(<span class="number">0</span>, <span class="number">10</span>, i =&gt; V.Start(<span class="string">"task "</span> + i).Sleep(i % <span class="number">3</span> + <span class="number">1</span>).Finish());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你将得到类似下面的执行过程：</p>
<p><img src="/images/blog/visualize_workshop_3.png" alt="task visualization 3"></p>
<h2 id="用神奇的图形抓住听众"><a href="#用神奇的图形抓住听众" class="headerlink" title="用神奇的图形抓住听众"></a>用神奇的图形抓住听众</h2><p>说实话，上面的图表的截图无法表现出他的全部。这些图表不但是有一定交互性的，例如，将鼠标移动到某一个任务上，将显示这个任务的开始，结束，执行长度等信息；而且是可以标记的。怎么样，有趣吗？如果你也想试一试，请参考我的 <a href="https://github.com/lxconan/TplWorkshop" target="_blank" rel="noopener">Workshop</a>。如果你想看答案，请参考 lx_dev 这个分支。</p>
<p>我相信，只要我的自动化图表足够炫，你会有这种去下载代码的冲动。这是听众的主动行为，代表了他们的兴趣，有兴趣还有什么搞不定的呢。</p>
<p>现实中复杂的东西实在太多，所以能够理解这些问题的，我们会认为他们很厉害。但是这种厉害分为两种，第一种是他讲的我都听不懂，有种不明觉厉的感觉；第二种是，这么复杂的东西能够用简单的例子描述出来，真厉害。我喜欢第二种。那么在制作 Workshop 之前，我们是不是应当好好考虑一下如何让听众觉得即形象，又具备足够的吸引力呢？</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/visualize/">visualize</a><a href="/tags/coaching/">coaching</a>
    </span>
    

    </div>

    
  </div>
</article>

  
	<section id="comment" class="comment">
	  <div id="disqus_thread">
	  <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
	  </div>
	</section>

	<script type="text/javascript">
	var disqus_shortname = 'lxconanblog';
	(function(){
	  var dsq = document.createElement('script');
	  dsq.type = 'text/javascript';
	  dsq.async = true;
	  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	}());
	(function(){
	  var dsq = document.createElement('script');
	  dsq.type = 'text/javascript';
	  dsq.async = true;
	  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
	  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	}());
	</script>





    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    <br>
    
    &copy; 2019 Liu Xia
    
  </p>
</footer>
    
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-47369838-1', 'auto');
    ga('send', 'pageview');

</script>

  </div>
</div>
</body>
</html>